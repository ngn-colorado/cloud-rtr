// ==============================================================
// File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
// Version: 2014.1
// Copyright (C) 2014 Xilinx Inc. All rights reserved.
// 
// ==============================================================

// Port list: {  1 1 1 1 1 1 1 1 1 1  }


#ifndef _aestest_sboxes_0_H_
#define _aestest_sboxes_0_H_



#include <systemc>
#include <iostream>
#include <fstream>
#include "AESL_pkg.h"

template<unsigned int READ_PORT_COUNT = 1,
         unsigned int WRITE_PORT_COUNT = 1,
         unsigned int DATA_WIDTH = 8,
         unsigned int ADDRESS_WIDTH = 8,
         unsigned int WORD_COUNT = 256>
struct aestest_sboxes_0_core : public sc_core::sc_module
{
public:
    sc_core::sc_in< sc_dt::sc_lv< WRITE_PORT_COUNT*DATA_WIDTH > > d;
    sc_core::sc_out< sc_dt::sc_lv< READ_PORT_COUNT*DATA_WIDTH > > q;
    sc_core::sc_in < sc_dt::sc_lv< READ_PORT_COUNT*ADDRESS_WIDTH > > ra;
    sc_core::sc_in < sc_dt::sc_lv< READ_PORT_COUNT > > ce;
    sc_core::sc_in < sc_dt::sc_lv< WRITE_PORT_COUNT*ADDRESS_WIDTH > > wa;
    sc_core::sc_in < sc_dt::sc_lv< WRITE_PORT_COUNT > > we;
    sc_core::sc_in <sc_dt::sc_logic>  reset;
    sc_core::sc_in_clk  clk;

    SC_HAS_PROCESS(aestest_sboxes_0_core);
    aestest_sboxes_0_core(sc_core::sc_module_name) {
        mem = new sc_dt::sc_lv< DATA_WIDTH> [WORD_COUNT];

        SC_METHOD(proc_di);
        sensitive << d;

        SC_METHOD(proc_wai);
        sensitive << wa;

        SC_METHOD(proc_mem);
        sensitive << clk.pos();

        SC_METHOD(proc_rai);
        sensitive << ra;

        SC_METHOD(proc_rai_reg);
        sensitive << clk.pos();

        SC_METHOD(proc_qi);
        sensitive << clk.pos();
        for (unsigned i = 0; i < READ_PORT_COUNT; i++) {
            sensitive << rai_reg[i];
        }

        SC_METHOD(proc_q);
        sensitive << qi;

        mem[0] = "01100011";
        mem[1] = "01111100";
        mem[2] = "01110111";
        mem[3] = "01111011";
        mem[4] = "11110010";
        mem[5] = "01101011";
        mem[6] = "01101111";
        mem[7] = "11000101";
        mem[8] = "00110000";
        mem[9] = "00000001";
        mem[10] = "01100111";
        mem[11] = "00101011";
        mem[12] = "11111110";
        mem[13] = "11010111";
        mem[14] = "10101011";
        mem[15] = "01110110";
        mem[16] = "11001010";
        mem[17] = "10000010";
        mem[18] = "11001001";
        mem[19] = "01111101";
        mem[20] = "11111010";
        mem[21] = "01011001";
        mem[22] = "01000111";
        mem[23] = "11110000";
        mem[24] = "10101101";
        mem[25] = "11010100";
        mem[26] = "10100010";
        mem[27] = "10101111";
        mem[28] = "10011100";
        mem[29] = "10100100";
        mem[30] = "01110010";
        mem[31] = "11000000";
        mem[32] = "10110111";
        mem[33] = "11111101";
        mem[34] = "10010011";
        mem[35] = "00100110";
        mem[36] = "00110110";
        mem[37] = "00111111";
        mem[38] = "11110111";
        mem[39] = "11001100";
        mem[40] = "00110100";
        mem[41] = "10100101";
        mem[42] = "11100101";
        mem[43] = "11110001";
        mem[44] = "01110001";
        mem[45] = "11011000";
        mem[46] = "00110001";
        mem[47] = "00010101";
        mem[48] = "00000100";
        mem[49] = "11000111";
        mem[50] = "00100011";
        mem[51] = "11000011";
        mem[52] = "00011000";
        mem[53] = "10010110";
        mem[54] = "00000101";
        mem[55] = "10011010";
        mem[56] = "00000111";
        mem[57] = "00010010";
        mem[58] = "10000000";
        mem[59] = "11100010";
        mem[60] = "11101011";
        mem[61] = "00100111";
        mem[62] = "10110010";
        mem[63] = "01110101";
        mem[64] = "00001001";
        mem[65] = "10000011";
        mem[66] = "00101100";
        mem[67] = "00011010";
        mem[68] = "00011011";
        mem[69] = "01101110";
        mem[70] = "01011010";
        mem[71] = "10100000";
        mem[72] = "01010010";
        mem[73] = "00111011";
        mem[74] = "11010110";
        mem[75] = "10110011";
        mem[76] = "00101001";
        mem[77] = "11100011";
        mem[78] = "00101111";
        mem[79] = "10000100";
        mem[80] = "01010011";
        mem[81] = "11010001";
        mem[82] = "00000000";
        mem[83] = "11101101";
        mem[84] = "00100000";
        mem[85] = "11111100";
        mem[86] = "10110001";
        mem[87] = "01011011";
        mem[88] = "01101010";
        mem[89] = "11001011";
        mem[90] = "10111110";
        mem[91] = "00111001";
        mem[92] = "01001010";
        mem[93] = "01001100";
        mem[94] = "01011000";
        mem[95] = "11001111";
        mem[96] = "11010000";
        mem[97] = "11101111";
        mem[98] = "10101010";
        mem[99] = "11111011";
        mem[100] = "01000011";
        mem[101] = "01001101";
        mem[102] = "00110011";
        mem[103] = "10000101";
        mem[104] = "01000101";
        mem[105] = "11111001";
        mem[106] = "00000010";
        mem[107] = "01111111";
        mem[108] = "01010000";
        mem[109] = "00111100";
        mem[110] = "10011111";
        mem[111] = "10101000";
        mem[112] = "01010001";
        mem[113] = "10100011";
        mem[114] = "01000000";
        mem[115] = "10001111";
        mem[116] = "10010010";
        mem[117] = "10011101";
        mem[118] = "00111000";
        mem[119] = "11110101";
        mem[120] = "10111100";
        mem[121] = "10110110";
        mem[122] = "11011010";
        mem[123] = "00100001";
        mem[124] = "00010000";
        mem[125] = "11111111";
        mem[126] = "11110011";
        mem[127] = "11010010";
        mem[128] = "11001101";
        mem[129] = "00001100";
        mem[130] = "00010011";
        mem[131] = "11101100";
        mem[132] = "01011111";
        mem[133] = "10010111";
        mem[134] = "01000100";
        mem[135] = "00010111";
        mem[136] = "11000100";
        mem[137] = "10100111";
        mem[138] = "01111110";
        mem[139] = "00111101";
        mem[140] = "01100100";
        mem[141] = "01011101";
        mem[142] = "00011001";
        mem[143] = "01110011";
        mem[144] = "01100000";
        mem[145] = "10000001";
        mem[146] = "01001111";
        mem[147] = "11011100";
        mem[148] = "00100010";
        mem[149] = "00101010";
        mem[150] = "10010000";
        mem[151] = "10001000";
        mem[152] = "01000110";
        mem[153] = "11101110";
        mem[154] = "10111000";
        mem[155] = "00010100";
        mem[156] = "11011110";
        mem[157] = "01011110";
        mem[158] = "00001011";
        mem[159] = "11011011";
        mem[160] = "11100000";
        mem[161] = "00110010";
        mem[162] = "00111010";
        mem[163] = "00001010";
        mem[164] = "01001001";
        mem[165] = "00000110";
        mem[166] = "00100100";
        mem[167] = "01011100";
        mem[168] = "11000010";
        mem[169] = "11010011";
        mem[170] = "10101100";
        mem[171] = "01100010";
        mem[172] = "10010001";
        mem[173] = "10010101";
        mem[174] = "11100100";
        mem[175] = "01111001";
        mem[176] = "11100111";
        mem[177] = "11001000";
        mem[178] = "00110111";
        mem[179] = "01101101";
        mem[180] = "10001101";
        mem[181] = "11010101";
        mem[182] = "01001110";
        mem[183] = "10101001";
        mem[184] = "01101100";
        mem[185] = "01010110";
        mem[186] = "11110100";
        mem[187] = "11101010";
        mem[188] = "01100101";
        mem[189] = "01111010";
        mem[190] = "10101110";
        mem[191] = "00001000";
        mem[192] = "10111010";
        mem[193] = "01111000";
        mem[194] = "00100101";
        mem[195] = "00101110";
        mem[196] = "00011100";
        mem[197] = "10100110";
        mem[198] = "10110100";
        mem[199] = "11000110";
        mem[200] = "11101000";
        mem[201] = "11011101";
        mem[202] = "01110100";
        mem[203] = "00011111";
        mem[204] = "01001011";
        mem[205] = "10111101";
        mem[206] = "10001011";
        mem[207] = "10001010";
        mem[208] = "01110000";
        mem[209] = "00111110";
        mem[210] = "10110101";
        mem[211] = "01100110";
        mem[212] = "01001000";
        mem[213] = "00000011";
        mem[214] = "11110110";
        mem[215] = "00001110";
        mem[216] = "01100001";
        mem[217] = "00110101";
        mem[218] = "01010111";
        mem[219] = "10111001";
        mem[220] = "10000110";
        mem[221] = "11000001";
        mem[222] = "00011101";
        mem[223] = "10011110";
        mem[224] = "11100001";
        mem[225] = "11111000";
        mem[226] = "10011000";
        mem[227] = "00010001";
        mem[228] = "01101001";
        mem[229] = "11011001";
        mem[230] = "10001110";
        mem[231] = "10010100";
        mem[232] = "10011011";
        mem[233] = "00011110";
        mem[234] = "10000111";
        mem[235] = "11101001";
        mem[236] = "11001110";
        mem[237] = "01010101";
        mem[238] = "00101000";
        mem[239] = "11011111";
        mem[240] = "10001100";
        mem[241] = "10100001";
        mem[242] = "10001001";
        mem[243] = "00001101";
        mem[244] = "10111111";
        mem[245] = "11100110";
        mem[246] = "01000010";
        mem[247] = "01101000";
        mem[248] = "01000001";
        mem[249] = "10011001";
        mem[250] = "00101101";
        mem[251] = "00001111";
        mem[252] = "10110000";
        mem[253] = "01010100";
        mem[254] = "10111011";
        mem[255] = "00010110";
    }


    void proc_di()
    {
        sc_dt::sc_lv<DATA_WIDTH> dt;
        for (unsigned i = 0; i < WRITE_PORT_COUNT; i++) {
            for (unsigned j = 0; j < DATA_WIDTH; j++) {
                dt.set_bit(j, d.read()[i * DATA_WIDTH + j].value());
            }
            di[i].write(dt);
        }
    }

    void proc_wai()
    {
        sc_dt::sc_lv<ADDRESS_WIDTH> wat;
        for (unsigned i = 0; i < WRITE_PORT_COUNT; i++) {
            for (unsigned j = 0; j < ADDRESS_WIDTH; j++) {
                wat.set_bit(j, wa.read()[i * ADDRESS_WIDTH + j].value());
            }
            wai[i].write(wat);
        }
    }


    void proc_mem()
    {
        for (unsigned j = 0; j < WRITE_PORT_COUNT; j++) {
          if (we.read().get_bit(j) == 1) {
            unsigned i = wai[j].read().to_uint();
            if (!wai[j].read().is_01() || i >= WORD_COUNT) {
               cerr << "In memory model " << name() << ", during a write cycle\n";
               if (!wai[j].read().is_01()) 
                 cerr << "ERROR: address is not stable =" << wai[j].read() << endl;
               else
                 cerr << "ERROR: Address " << i << " for port '" << j << "' is outside the legal range [0.."
                      << (WORD_COUNT - 1) << "]." << endl;
               SC_REPORT_FATAL(1000, 0);
            }
            assert(wai[j].read().is_01());
            assert(i < WORD_COUNT);
            mem[i] = di[j];
          }
        }
    }


    void proc_rai()
    {
        sc_dt::sc_lv<ADDRESS_WIDTH> rat;
        for (unsigned i = 0; i < READ_PORT_COUNT; i++) {
            for (unsigned j = 0; j < ADDRESS_WIDTH; j++) {
                rat.set_bit(j, ra.read()[i * ADDRESS_WIDTH + j].value());
            }
            rai[i].write(rat);
        }
    }

    void proc_rai_reg()
    {
        for (unsigned i = 0; i < READ_PORT_COUNT; i++) {
            if ( ce.read().get_bit(i) == 1) {
                rai_reg[i] = rai[i];
            }
        }
    }

    void proc_qi()
    {
        sc_dt::sc_lv<DATA_WIDTH> qt;
        sc_dt::sc_lv<READ_PORT_COUNT*DATA_WIDTH> qit;
        for (unsigned i = 0; i < READ_PORT_COUNT; i++) {
            if (!(rai_reg[i].read().is_01())) 
                qt = sc_dt::sc_lv<DATA_WIDTH>();
            else 
            {
                unsigned addr = rai_reg[i].read().to_uint();
                if (addr >= WORD_COUNT) {
                    qt = sc_dt::sc_lv<DATA_WIDTH>();
                }
                else {
                    qt = mem[addr];
                }
            }
            for (unsigned j = 0; j < DATA_WIDTH; j++) {
                qit.set_bit(i*DATA_WIDTH+j, qt[j].value());
            }
        }
        qi.write(qit);
    }


    void proc_q()
    {
        q.write(qi.read());
    }

    ~aestest_sboxes_0_core() {
        delete [] mem;
    }

public:
    sc_dt::sc_lv< DATA_WIDTH>*  mem;
    sc_core::sc_signal<sc_dt::sc_lv<ADDRESS_WIDTH> > wai[ WRITE_PORT_COUNT ];
    sc_core::sc_signal<sc_dt::sc_lv<ADDRESS_WIDTH> > rai[READ_PORT_COUNT];
    sc_core::sc_signal<sc_dt::sc_lv<ADDRESS_WIDTH> > rai_reg[READ_PORT_COUNT];
    sc_core::sc_signal<sc_dt::sc_lv<DATA_WIDTH> > di[WRITE_PORT_COUNT];
    sc_core::sc_signal<sc_dt::sc_lv<READ_PORT_COUNT*DATA_WIDTH> > qi;
};

  


SC_MODULE( aestest_sboxes_0 )
{
    static const unsigned int DataWidth = 8;
    static const unsigned int AddressRange = 256;
    static const unsigned int AddressWidth = 8;


    sc_core::sc_in<sc_dt::sc_lv<AddressWidth> > address0;
    sc_core::sc_in<sc_dt::sc_logic> ce0;
    sc_core::sc_out<sc_dt::sc_lv<DataWidth> > q0;

    sc_core::sc_in<sc_dt::sc_lv<AddressWidth> > address1;
    sc_core::sc_in<sc_dt::sc_logic> ce1;
    sc_core::sc_out<sc_dt::sc_lv<DataWidth> > q1;

    sc_core::sc_in<sc_dt::sc_lv<AddressWidth> > address2;
    sc_core::sc_in<sc_dt::sc_logic> ce2;
    sc_core::sc_out<sc_dt::sc_lv<DataWidth> > q2;

    sc_core::sc_in<sc_dt::sc_lv<AddressWidth> > address3;
    sc_core::sc_in<sc_dt::sc_logic> ce3;
    sc_core::sc_out<sc_dt::sc_lv<DataWidth> > q3;

    sc_core::sc_in<sc_dt::sc_lv<AddressWidth> > address4;
    sc_core::sc_in<sc_dt::sc_logic> ce4;
    sc_core::sc_out<sc_dt::sc_lv<DataWidth> > q4;

    sc_core::sc_in<sc_dt::sc_lv<AddressWidth> > address5;
    sc_core::sc_in<sc_dt::sc_logic> ce5;
    sc_core::sc_out<sc_dt::sc_lv<DataWidth> > q5;

    sc_core::sc_in<sc_dt::sc_lv<AddressWidth> > address6;
    sc_core::sc_in<sc_dt::sc_logic> ce6;
    sc_core::sc_out<sc_dt::sc_lv<DataWidth> > q6;

    sc_core::sc_in<sc_dt::sc_lv<AddressWidth> > address7;
    sc_core::sc_in<sc_dt::sc_logic> ce7;
    sc_core::sc_out<sc_dt::sc_lv<DataWidth> > q7;

    sc_core::sc_in<sc_dt::sc_lv<AddressWidth> > address8;
    sc_core::sc_in<sc_dt::sc_logic> ce8;
    sc_core::sc_out<sc_dt::sc_lv<DataWidth> > q8;

    sc_core::sc_in<sc_dt::sc_lv<AddressWidth> > address9;
    sc_core::sc_in<sc_dt::sc_logic> ce9;
    sc_core::sc_out<sc_dt::sc_lv<DataWidth> > q9;

    sc_core::sc_in<sc_dt::sc_logic> reset;
    sc_core::sc_in_clk clk;


    SC_CTOR( aestest_sboxes_0 ) {
        meminst = new aestest_sboxes_0_core <10, 1, DataWidth, AddressWidth, AddressRange>("core_inst");

        meminst->d(mem_d);
        meminst->q(mem_q);
        meminst->ra(mem_ra);
        meminst->ce(mem_ce);
        meminst->wa(mem_wa);
        meminst->we(mem_we);
        meminst->reset(reset);
        meminst->clk(clk);

        SC_METHOD(proc_mem_q);
        sensitive << mem_q;

        SC_METHOD(proc_mem_ra);
        sensitive << address0 << address1 << address2 << address3 << address4 << address5 << address6 << address7 << address8 << address9;

        SC_METHOD(proc_mem_ce);
        sensitive << ce0 << ce1 << ce2 << ce3 << ce4 << ce5 << ce6 << ce7 << ce8 << ce9;

        mem_wa.write(0);
        mem_we.write(0);
        mem_d.write(0);
    }

    ~aestest_sboxes_0() {
        delete meminst;
    }

    void proc_mem_q();
    void proc_mem_ra();
    void proc_mem_ce();

public:
    sc_core::sc_signal<sc_dt::sc_lv<10 * DataWidth> > mem_q;
    sc_core::sc_signal<sc_dt::sc_lv<1> > mem_we;
    sc_core::sc_signal<sc_dt::sc_lv<1 * DataWidth> > mem_d;
    sc_core::sc_signal<sc_dt::sc_lv<1 * AddressWidth> > mem_wa;
    sc_core::sc_signal<sc_dt::sc_lv<10 * AddressWidth> > mem_ra;
    sc_core::sc_signal<sc_dt::sc_lv<10> > mem_ce;

    aestest_sboxes_0_core <10, 1, DataWidth, AddressWidth, AddressRange>* meminst;
};

#endif //_aestest_sboxes_0_H_
