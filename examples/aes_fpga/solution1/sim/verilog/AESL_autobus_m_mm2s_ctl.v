// =============================================================
// File generated by AutoESL - High-Level Synthesis System (C, C++, SystemC
// Version: 2012.
// Copyright (C) 2012 Xilinx Inc. All rights reserved 
// 
// ============================================================= 
`timescale 1 ns / 1 ps 
 
module AESL_autobus_m_mm2s_ctl ( 
    clk, 
    rst, 
    bus_req_RW, 
    bus_req_full_n, 
    bus_req_RW_en, 
    bus_rsp_empty_n, 
    bus_rsp_read, 
    bus_address, 
    bus_din, 
    bus_dout, 
    bus_size, 
    ready, 
    done 
    ); 
 
//------------------------Parameter---------------------- 
localparam 
    TV_IN  = "../tv/cdatafile/c.aes.autotvin_m_mm2s_ctl.dat";
localparam 
    TV_OUT = "../tv/rtldatafile/rtl.aes.autotvout_m_mm2s_ctl.dat";
//------------------------Local signal------------------- 
parameter   DATA_WIDTH            =   32'd 32; 
parameter   ADDR_WIDTH            =   32'd 32; 
parameter   DEPTH                 =   32'd 500; 
parameter   FIFO_rsp_DEPTH        =   32'd 500;
parameter   FIFO_DEPTH            =   32'd 32; 
parameter   FIFO_DEPTH_ADDR_WIDTH   =    32'd 32; 
 
// Input and Output 
input   clk; 
input   rst; 
input    bus_req_RW; 
output    bus_req_full_n; 
input    bus_req_RW_en; 
output   bus_rsp_empty_n; 
input    bus_rsp_read; 
input    [ADDR_WIDTH - 1 : 0]    bus_address; 
input    [DATA_WIDTH - 1 : 0]    bus_din; 
output   [DATA_WIDTH - 1 : 0]    bus_dout; 
input    [31 : 0]        bus_size; 
input    ready; 
input    done; 
 
// Inner signals 
reg    [0 : 0]                FIFO_req_RW        [0 : FIFO_DEPTH - 1]; 
reg    [ADDR_WIDTH - 1 : 0]        FIFO_req_address    [0 : FIFO_DEPTH - 1]; 
reg    [DATA_WIDTH - 1 : 0]        FIFO_req_din        [0 : FIFO_DEPTH - 1]; 
reg    [31 : 0]            FIFO_req_size        [0 : FIFO_DEPTH - 1]; 
reg    [FIFO_DEPTH_ADDR_WIDTH - 1 : 0]    FIFO_req_ptr_r = 0; 
reg    [FIFO_DEPTH_ADDR_WIDTH - 1 : 0]    FIFO_req_ptr_w = 0; 
reg    FIFO_req_flag    =   0;        // '0' for empty, '1' for full 
reg    FIFO_req_empty = 1; 
reg    FIFO_req_full = 0; 
reg    FIFO_req_read = 0;            // Read signal for FIFO_req 
reg    FIFO_req_burst_flag; 
reg    [ADDR_WIDTH - 1 : 0]         FIFO_rsp_ptr_r = 0;
reg    [ADDR_WIDTH - 1 : 0]         FIFO_rsp_ptr_w = 0;
reg    FIFO_rsp_flag    =   0;        // '0' for empty, '1' for full 
reg    FIFO_rsp_empty = 1; 
reg    FIFO_rsp_full = 0; 
reg    FIFO_rsp_write = 0; 
reg    [DATA_WIDTH - 1 : 0]    bus_dout; 
reg    [DATA_WIDTH - 1 : 0]        FIFO_rsp_mem    [0 : FIFO_rsp_DEPTH - 1]; 
initial begin : initialize_FIFO_rsp_mem
  integer i;
  for (i = 0; i < FIFO_rsp_DEPTH; i = i + 1) begin
      FIFO_rsp_mem[i] = 0;
  end
end
reg    [DATA_WIDTH - 1 : 0]        mem    [0 : DEPTH - 1]; 
initial begin : initialize_mem
  integer i;
  for (i = 0; i < DEPTH; i = i + 1) begin
      mem[i] = 0;
  end
end
 
assign    bus_rsp_empty_n     =   !FIFO_rsp_empty;
assign    bus_req_full_n    =    !FIFO_req_full; 
always @ (posedge clk) begin
  # 0.4;
  bus_dout <= FIFO_rsp_mem[FIFO_rsp_ptr_r];
end
 
// Generate "FIFO_req_empty" and "FIFO_req_full" 
always @ (FIFO_req_ptr_r or FIFO_req_ptr_w or FIFO_req_flag) begin 
    if(FIFO_req_ptr_r == FIFO_req_ptr_w) begin 
    if(FIFO_req_flag) begin 
        FIFO_req_full   = 1; 
        FIFO_req_empty  = 0; 
    end 
    else begin 
        FIFO_req_full   = 0; 
        FIFO_req_empty  = 1; 
    end 
    end 
    else begin 
        FIFO_req_full    = 0; 
        FIFO_req_empty    = 0; 
    end 
end 
 
 
// Generate "FIFO_rsp_empty" and "FIFO_rsp_full" 
always @ (FIFO_rsp_ptr_r or FIFO_rsp_ptr_w or FIFO_rsp_flag) begin 
  if(FIFO_rsp_ptr_r == FIFO_rsp_ptr_w) begin 
      if(FIFO_rsp_flag) begin 
          FIFO_rsp_full   = 1; 
          FIFO_rsp_empty  = 0; 
      end 
      else begin 
          FIFO_rsp_full   = 0; 
          FIFO_rsp_empty  = 1; 
      end 
  end 
  else begin 
      FIFO_rsp_full    = 0; 
      FIFO_rsp_empty    = 0; 
  end 
end 
 
 
// Push RTL's req into FIFO_req 
always @ (posedge clk or rst) begin 
    if(rst === 0) begin 
        FIFO_req_ptr_w <= 0; 
    end 
    else begin 
        if(bus_req_RW_en & !FIFO_req_full) begin    // RTL is sending a request to the bus         
            FIFO_req_RW[FIFO_req_ptr_w]        =   bus_req_RW; 
            FIFO_req_address[FIFO_req_ptr_w]    =   bus_address; 
            FIFO_req_din[FIFO_req_ptr_w]    =   bus_din; 
            FIFO_req_size[FIFO_req_ptr_w]    =   bus_size; 
            if(FIFO_req_ptr_w != FIFO_DEPTH - 1) 
                FIFO_req_ptr_w <= FIFO_req_ptr_w + 1; 
            else 
                FIFO_req_ptr_w <= 0; 
       end 
    end 
end 
 
reg    [0 : 0]            FIFO_req_RW_temp; 
reg    [ADDR_WIDTH - 1 : 0]    FIFO_req_address_temp; 
reg    [DATA_WIDTH - 1 : 0]    FIFO_req_din_temp; 
reg    [31 : 0]        FIFO_req_size_temp; 
 
 
 
parameter    IDLE_STATE        =    0; 
parameter    READ_BURST_STATE    =    1; 
parameter    WRITE_BURST_STATE    =    2; 
reg    [1 : 0]    FIFO_req_temp_state; 
// Processing the pop RTL's req 
always @ (posedge clk or rst) begin 
    if(rst === 0) begin 
    FIFO_req_temp_state    <= IDLE_STATE; 
    FIFO_req_read <= 0; 
    FIFO_rsp_write <= 0; 
    end 
    else begin 
    case(FIFO_req_temp_state) 
        IDLE_STATE:  
        begin 
            if(!FIFO_req_empty && !FIFO_rsp_full) begin 
                FIFO_req_read <= 1; 
                if(FIFO_req_ptr_r != FIFO_DEPTH - 1)
                    FIFO_req_ptr_r <= FIFO_req_ptr_r + 1;
                else
                    FIFO_req_ptr_r <= 0;
                FIFO_req_RW_temp = FIFO_req_RW[FIFO_req_ptr_r]; 
                FIFO_req_address_temp = FIFO_req_address[FIFO_req_ptr_r]; 
                if (FIFO_req_address_temp > DEPTH ) $finish;
                FIFO_req_din_temp = FIFO_req_din[FIFO_req_ptr_r]; 
                FIFO_req_size_temp = FIFO_req_size[FIFO_req_ptr_r]; 
                // Read request 
                if(!FIFO_req_RW_temp) begin                 
                    FIFO_rsp_write <= 1;            // Indicate the output is valid 
                    FIFO_rsp_mem[FIFO_rsp_ptr_w] = mem[FIFO_req_address_temp]; 
                    if(FIFO_rsp_ptr_w != FIFO_rsp_DEPTH - 1)
                        FIFO_rsp_ptr_w <= FIFO_rsp_ptr_w + 1;
                    else
                        FIFO_rsp_ptr_w <= 0;
                    if(FIFO_req_size_temp != 0 && FIFO_req_size_temp != 1) begin    // Read burst request 
                        FIFO_req_temp_state <= READ_BURST_STATE;        // To deal with the rest data 
                    end 
                end 
                // Write request 
                else begin             
                    FIFO_rsp_write <= 0;            // Indicate the output is not valid                 
                    if(FIFO_req_size_temp == 0 || FIFO_req_size_temp == 1)    // Write single request 
                        mem[FIFO_req_address_temp] = FIFO_req_din_temp; 
                    else begin                            // Write burst request 
                        mem[FIFO_req_address_temp] = FIFO_req_din_temp; // Input the first data 
                        FIFO_req_temp_state <= WRITE_BURST_STATE;        // To deal with the rest data 
                    end 
                end 
            end 
            else begin    // There is no request in the FIFO_req 
                FIFO_req_read <= 0; 
                FIFO_rsp_write <= 0; 
            end 
        end 
        READ_BURST_STATE: 
        begin 
            FIFO_req_read <= 0;    // Stop reading the next request 
            FIFO_req_size_temp = FIFO_req_size_temp - 1; 
            if(FIFO_req_address_temp != DEPTH - 1) begin
                FIFO_req_address_temp = FIFO_req_address_temp + 1; 
            end 
            else begin
                $display("Burst read out of size!"); 
                $finish;
            end 
            FIFO_rsp_mem[FIFO_rsp_ptr_w] = mem[FIFO_req_address_temp]; 
            if(FIFO_rsp_ptr_w != FIFO_rsp_DEPTH - 1)
                FIFO_rsp_ptr_w <= FIFO_rsp_ptr_w + 1;
            else 
                FIFO_rsp_ptr_w <= 0;
            if(FIFO_req_size_temp == 1)     // The last one is done 
                FIFO_req_temp_state <= IDLE_STATE; 
        end 
        WRITE_BURST_STATE: 
        begin 
            if(!FIFO_req_empty) begin 
                FIFO_req_read <= 1;    // Keep reading the next data(The data is storaged in FIFO_req but it is not a request) 
                if(FIFO_req_ptr_r != FIFO_DEPTH - 1)
                    FIFO_req_ptr_r <= FIFO_req_ptr_r + 1;
                else
                    FIFO_req_ptr_r <= 0;
                FIFO_req_size_temp = FIFO_req_size_temp - 1; 
                if(FIFO_req_address_temp != DEPTH - 1) begin 
                    FIFO_req_address_temp = FIFO_req_address_temp + 1; 
                end 
                else begin
                    $display("Burst write out of size!"); 
                    $finish;
                end 
                mem[FIFO_req_address_temp] = FIFO_req_din[FIFO_req_ptr_r]; 
                if(FIFO_req_size_temp == 1)     // The last one is done 
                    FIFO_req_temp_state <= IDLE_STATE; 
            end
        end 
    endcase 
    end 
end 
 
// Generate "FIFO_req_flag" 
always @(posedge clk or rst) begin 
    if(rst === 0) begin 
      FIFO_req_flag <= 0; 
    end
    else begin 
      if(bus_req_RW_en && !FIFO_req_full && (FIFO_req_ptr_w == FIFO_DEPTH - 1)) 
          FIFO_req_flag <= 1; 
      # 0.4;
      if(FIFO_req_read && !FIFO_req_empty && (FIFO_req_ptr_r == 0)) 
          FIFO_req_flag <= 0; 
    end 
end 
 
// Generate "FIFO_rsp_flag" 
always @(posedge clk or rst) begin 
    if(rst === 0) begin 
      FIFO_rsp_flag <= 0; 
    end
    else begin 
      if(bus_rsp_read && !FIFO_rsp_empty && (FIFO_rsp_ptr_r == FIFO_rsp_DEPTH - 1)) 
          FIFO_rsp_flag <= 0; 
      # 0.4;
      if(FIFO_rsp_write && !FIFO_rsp_full && (FIFO_rsp_ptr_w == 0)) 
          FIFO_rsp_flag <= 1; 
    end 
end 
 
 
 
// Pop data from FIFO_rsp 
always @ (posedge clk or rst) begin 
    if(rst === 0) begin 
      FIFO_rsp_ptr_r <= 0; 
    end 
    else begin 
      if(bus_rsp_read & !FIFO_rsp_empty) begin 
          if(FIFO_rsp_ptr_r != FIFO_rsp_DEPTH - 1) 
              FIFO_rsp_ptr_r <= FIFO_rsp_ptr_r + 1; 
          else 
              FIFO_rsp_ptr_r <= 0; 
      end 
    end 
end 
 
 
//------------------------Task and function-------------- 
task read_token; 
    input integer fp; 
    output reg [127 :0] token; 
    reg [7:0] c; 
    reg intoken; 
    reg done; 
    begin 
        token = ""; 
        intoken = 0; 
        done = 0; 
        while (!done) begin 
            c = $fgetc(fp); 
            if (c == 8'hff) begin   // EOF 
                done = 1; 
            end 
            else if (c == " " || c == "\011" || c == "\012" || c == "\015") begin   // blank 
                if (intoken) begin 
                    done = 1; 
                end 
            end 
            else begin              // valid character 
                intoken = 1; 
                token = (token << 8) | c; 
            end 
        end 
    end 
endtask 
 
//------------------------Read file------------------------ 
 
// Read data from file 
initial begin : read_file_process 
  integer fp; 
  integer err; 
  integer ret; 
  reg [127 : 0] token; 
  reg [ 8*5 : 1] str;
  integer transaction_idx; 
  integer i; 
  transaction_idx = 0; 
  fp = $fopen(TV_IN,"r"); 
  if(fp == 0) begin                               // Failed to open file 
      $display("Failed to open file \"%s\"!", TV_IN); 
      $finish; 
  end 
  read_token(fp, token); 
  if (token != "[[[runtime]]]") begin             // Illegal format 
      $display("ERROR: Simulation using HLS TB failed.");
      $finish; 
  end 
  read_token(fp, token); 
  while (token != "[[[/runtime]]]") begin 
      if (token != "[[transaction]]") begin 
          $display("ERROR: Simulation using HLS TB failed.");
          $finish; 
      end 
      read_token(fp, token);                        // skip transaction number 
      @(posedge clk);
      # 0.2;
      while(ready !== 1) begin
          @(posedge clk); 
          # 0.2;
      end
      for(i = 0; i < DEPTH; i = i + 1) begin 
          read_token(fp, token); 
          ret = $sscanf(token, "0x%x", mem[i]); 
          if (ret != 1) begin 
              $display("Failed to parse token!"); 
              $finish; 
          end 
      end 
      read_token(fp, token); 
      if(token != "[[/transaction]]") begin 
          $display("ERROR: Simulation using HLS TB failed.");
          $finish; 
      end 
      read_token(fp, token); 
      transaction_idx = transaction_idx + 1; 
  end 
  $fclose(fp); 
end 
 
//------------------------Write file----------------------- 
 
// Write data to file 
 
initial begin : write_file_proc 
  integer fp; 
  integer transaction_idx; 
  reg [ 100*8 : 1] str;
  integer i; 
  transaction_idx = 0; 
  while(1) begin 
      @(posedge clk);
      while(done !== 1) begin
          @(posedge clk);
      end
      # 0.1;
      fp = $fopen(TV_OUT, "a"); 
      if(fp == 0) begin       // Failed to open file 
          $display("Failed to open file \"%s\"!", TV_OUT); 
          $finish; 
      end 
      $fdisplay(fp, "[[transaction]] %d", transaction_idx);
      for (i = 0; i < DEPTH; i = i + 1) begin
          $fdisplay(fp,"0x%x",mem[i]);
      end 
      $fdisplay(fp, "[[/transaction]]");
      transaction_idx = transaction_idx + 1;
      $fclose(fp); 
  end 
end 
 
endmodule   

